/*  - script used for line following  - uses an fsm to function  - used for debugging  - author: ilie, pieris  Motor movement directions              + | -  motor 1:    <-|->  motor 2:    fw|bw  motor 3:    <-|->  motor 4:    fw|bw*/// Libraries used for motor movement#include <SDPArduino.h>#include <Wire.h>// #include <Rotary.h>// Libraries used for sesnor control#include <QTRSensors.h>// Variables for Sensors#define HARDCODE_CALIBRATION false#define NUM_SENSORS   8     // number of sensors used#define NUM_BOARDS 3        // number of boards#define TIMEOUT       2500  // waits for 2500 microseconds for sensor outputs to go low#define EMITTER_PIN0   50#define EMITTER_PIN1   5#define EMITTER_PIN2   39#define EMITTER_PIN3   38//--------------------Globals for motor control-------------------double Kp = 0.01;// double Ki;double Kd = 0.05;int ERROR_calib = 3500;double motors_speed = 0;      // global used for speed of right mototrsdouble line_last_error    = 0;      // global that holds last error from fwd sensorsdouble line_new_error     = 0;double mottor_adjustment  = 0;      // global used to readjust mottor speeddouble right_motors_default_speed = 50;    // global used as default speed of right motorsdouble left_motors_default_speed  = 50 ;   // global used as default speed of left motorsdouble right_max_speed = 100   ;           // max speed of right mototrsdouble left_max_speed  = 100  ;            // max speed of left motorsdouble range_left = 2500;double range_right = 5500;double motor1_old = 0;double motor2_old = 0;double motor3_old = 0;double motor4_old = 0;double motor1_current = 0;double motor2_current = 0;double motor3_current = 0;double motor4_current = 0;// DEBUGGINGint counter = 0;int sensor_fwd_reading = 0;//--------------------Globals for Sensor control-------------------// sensors 0 through 7 are connected to digital pins 3 through 10, respectivelyQTRSensorsRC qtrrc0((unsigned char[]) {  6, 7, 8, 9, 10, 11, 12, 13},NUM_SENSORS, TIMEOUT, EMITTER_PIN0);QTRSensorsRC qtrrc1((unsigned char[]) {  6, 7, 8, 9, 10, 11, 12, 13},NUM_SENSORS, TIMEOUT, EMITTER_PIN1);QTRSensorsRC qtrrc2((unsigned char[]) {  37, 35, 33, 31, 29, 27, 25, 23},NUM_SENSORS, TIMEOUT, EMITTER_PIN2);QTRSensorsRC qtrrc3((unsigned char[]) {  52, 53, 51, 49, 47, 45, 43, 41},NUM_SENSORS, TIMEOUT, EMITTER_PIN3);QTRSensorsRC qtrrcs[4];unsigned int sensorValues[NUM_SENSORS];//-------------------------------------------------------------------------------//                           Movement functions//-------------------------------------------------------------------------------void motor_move(int id, double speed) {  Serial.println("INSIDE motor_move");  if (speed >= 0) {    motorForward(id, speed);    Serial.print("FWD: id ");    Serial.println(id);    Serial.print("FWD: speed ");    Serial.println(speed);  }  else {    motorBackward(id, abs(speed));    Serial.print("BKW: id ");    Serial.println(id);    Serial.print("BKW: speed ");    Serial.println(speed);  }  // delay(500);}void turn_left(int speed_input) {  // Stop fwd/bkw movement when turning  motorStop(2);  motorStop(4);  // Local vars  double speed_input_horizontal;  double speed_input_forward;  // make sure you don't go over 100  if (abs(70 + speed_input) > 100) {    speed_input_horizontal = 100;  }  else {    speed_input_horizontal = speed_input + 70;  }  motor1_current = speed_input_horizontal;  motor3_current = speed_input_horizontal;  // forward wheels can't go over 80  if (abs(50 + speed_input > 80)) {    speed_input_forward = 80;  }  else {    speed_input_forward = 50 + speed_input;  }  if (check_change_rotation() == true) {    //Serial.println("ACTUALLY TURNING RIGHT WITH SPEED:",speed_input_horizontal)    motor_move(1,  -1 * speed_input_horizontal);    // motor_move(2, -1 * speed_input_forward);    motor_move(3,  1 * speed_input_horizontal);    // motor_move(4,  1 * speed_input_forward);    motor1_old =  -1 * speed_input_horizontal;    motor2_old = -1 * speed_input_forward;    motor3_old =  1 * speed_input_horizontal;    motor4_old =  1 * speed_input_forward;  }}void turn_right(int speed_input) {  // Stop fwd/bkw movement when turning  motorStop(2);  motorStop(4);  // Local vars  double speed_input_horizontal;  double speed_input_forward;  // make sure you don't go over 100  if (abs(70 + speed_input) > 100) {    speed_input_horizontal = 100;  }  else {    speed_input_horizontal = speed_input + 70;  }  motor1_current = speed_input_horizontal;  motor3_current = speed_input_horizontal;  if (abs(50 + speed_input > 80)) {    speed_input_forward = 80;  }  else {    speed_input_forward = 50 + speed_input;  }  if (check_change_rotation() == true) {    //Serial.println("ACTUALLY TURNING LEFT WITH SPEED:",speed_input_horizontal)    motor_move(1, 1 * speed_input_horizontal);    // motor_move(2, speed_input_forward);    motor_move(3, -1 * speed_input_horizontal);    // motor_move(4, speed_input_forward);    motor1_old = 1 * speed_input_horizontal;    motor2_old = speed_input_forward;    motor3_old = -1 * speed_input_horizontal;    motor4_old = speed_input_forward;  }}bool check_change_forward() {  if ((abs(motor2_old - motor2_current) > 8) || (abs(motor4_old - motor4_current) > 8)) {    motor2_old = motor2_current;    motor4_old = motor4_current;    return true;  }  else {    return false;  }}bool check_change_rotation() {  if (abs(motor1_old - motor1_current) > 8) {    motor1_old = motor1_current;    motor3_old = motor3_current;    return true;  }  else {    return false;  }}//////////////////////////////////////////////////////void setup() {  //---------------------- Setting up the motors-----------------  Serial.begin(9600);  // Serial at given baudrate  Serial.println("Serial Print Initialized");  SDPsetup();  Wire.begin();  // Master of the I2C bus  // --------------------  Setting up the sensors ---------------  delay(500);  pinMode(13, OUTPUT);  digitalWrite(13, HIGH);    // turn on Arduino's LED to indicate we are in calibration mode  qtrrcs[0] = qtrrc0;   // FRONT  qtrrcs[1] = qtrrc1;   // RIGHT  qtrrcs[2] = qtrrc2;   // BACK  qtrrcs[3] = qtrrc3;   // LEFT  // Calibrating Front Sensor  qtrrcs[0].calibrate(); // calibrate once to set up arrays  qtrrcs[0].calibratedMinimumOn[0] = 280;  qtrrcs[0].calibratedMinimumOn[1] = 224;  qtrrcs[0].calibratedMinimumOn[2] = 220;  qtrrcs[0].calibratedMinimumOn[3] = 224;  qtrrcs[0].calibratedMinimumOn[4] = 168;  qtrrcs[0].calibratedMinimumOn[5] = 168;  qtrrcs[0].calibratedMinimumOn[6] = 168;  qtrrcs[0].calibratedMinimumOn[7] = 168;  qtrrcs[0].calibratedMaximumOn[0] = 2500;  qtrrcs[0].calibratedMaximumOn[1] = 2500;  qtrrcs[0].calibratedMaximumOn[2] = 2500;  qtrrcs[0].calibratedMaximumOn[3] = 2500;  qtrrcs[0].calibratedMaximumOn[4] = 2500;  qtrrcs[0].calibratedMaximumOn[5] = 2500;  qtrrcs[0].calibratedMaximumOn[6] = 2500;  qtrrcs[0].calibratedMaximumOn[7] = 2500;  // Calibrating Right Sensor  qtrrcs[1].calibrate(); // calibrate once to set up arrays  qtrrcs[1].calibratedMinimumOn[0] = 280;  qtrrcs[1].calibratedMinimumOn[1] = 224;  qtrrcs[1].calibratedMinimumOn[2] = 220;  qtrrcs[1].calibratedMinimumOn[3] = 224;  qtrrcs[1].calibratedMinimumOn[4] = 168;  qtrrcs[1].calibratedMinimumOn[5] = 168;  qtrrcs[1].calibratedMinimumOn[6] = 168;  qtrrcs[1].calibratedMinimumOn[7] = 168;  qtrrcs[1].calibratedMaximumOn[0] = 2500;  qtrrcs[1].calibratedMaximumOn[1] = 2500;  qtrrcs[1].calibratedMaximumOn[2] = 2500;  qtrrcs[1].calibratedMaximumOn[3] = 2500;  qtrrcs[1].calibratedMaximumOn[4] = 2500;  qtrrcs[1].calibratedMaximumOn[5] = 2500;  qtrrcs[1].calibratedMaximumOn[6] = 2500;  qtrrcs[1].calibratedMaximumOn[7] = 2500;  // Calibrating Left Sensor  qtrrcs[3].calibrate(); // calibrate once to set up arrays  qtrrcs[3].calibratedMinimumOn[0] = 280;  qtrrcs[3].calibratedMinimumOn[1] = 224;  qtrrcs[3].calibratedMinimumOn[2] = 220;  qtrrcs[3].calibratedMinimumOn[3] = 224;  qtrrcs[3].calibratedMinimumOn[4] = 168;  qtrrcs[3].calibratedMinimumOn[5] = 168;  qtrrcs[3].calibratedMinimumOn[6] = 168;  qtrrcs[3].calibratedMinimumOn[7] = 168;  qtrrcs[3].calibratedMaximumOn[0] = 2500;  qtrrcs[3].calibratedMaximumOn[1] = 2500;  qtrrcs[3].calibratedMaximumOn[2] = 2500;  qtrrcs[3].calibratedMaximumOn[3] = 2500;  qtrrcs[3].calibratedMaximumOn[4] = 2500;  qtrrcs[3].calibratedMaximumOn[5] = 2500;  qtrrcs[3].calibratedMaximumOn[6] = 2500;  qtrrcs[3].calibratedMaximumOn[7] = 2500;  digitalWrite(13, LOW);     // turn off Arduino's LED to indicate we are through with calibration  delay(3000);}void loop() {  //------------------- Sensors values ---------------  // FRONT  // unsigned int position_front = qtrrcs[0].readLine(sensorValues);  // Serial.print(position_front); // comment this line out if you are using raw values  // Serial.print(' ');  // // RIGHT  // unsigned int position_right = qtrrcs[1].readLine(sensorValues);  // Serial.print(position_right); // comment this line out if you are using raw values  // Serial.print(' ');  // // BACK  // unsigned int position_back = qtrrcs[2].readLine(sensorValues);  // Serial.print(position_back); // comment this line out if you are using raw values  // Serial.print(' ');  // // LEFT  // unsigned int position_left = qtrrcs[3].readLine(sensorValues);  // Serial.print(position_left); // comment this line out if you are using raw values  // Serial.print(' ');  // delay(1000);  /*    //------------------- Motors FSM -------------------    if (sensor_fwd_reading >= 7000) {    motorAllStop();    } else {    //get value from sensor    sensor_fwd_reading += 30 ;    Serial.print("sensor_fwd_reading = ");    Serial.println(sensor_fwd_reading);    //calculate motor speed    double motors_speed_old = motors_speed;    line_new_error = sensor_fwd_reading - ERROR_calib;    mottor_adjustment = Kp * line_new_error + Kd * (line_new_error - line_last_error);    line_last_error = line_new_error;    motors_speed = mottor_adjustment;    // make sure you don't go over 100    if (motors_speed > 100) {      motors_speed = 100;    }    else if (motors_speed < -100) {      motors_speed = -100;    }    motors_speed = abs(motors_speed);    //move motors    if (sensor_fwd_reading < range_left) {      Serial.print("TURNING LEFT WITH SPEED:  ");      Serial.println(motors_speed * 3);      motor1_current = motors_speed;      motor3_current = motors_speed;      turn_left(motors_speed);    }    else if (sensor_fwd_reading > range_right) {      Serial.print("TURNING RIGHT WITH SPEED: ");      Serial.println(motors_speed);      turn_right(motors_speed);    }    else if (sensor_fwd_reading >= range_left && sensor_fwd_reading <= range_right) {      Serial.println("MOVING FORWARD");      motor2_current = 70;      motor4_current = 70;      if (check_change_forward() == true) {        motorStop(1);        motorStop(3);        motor_move(4, 70);        motor_move(2, 70);        Serial.println("INSIDE FORWARD");        motor2_old = motor2_current;        motor4_old = motor4_current;        Serial.print("motor2_current");        Serial.println(motor2_current);        Serial.print("motor4_current");        Serial.println(motor4_current);      }    }    else {      Serial.println("MOTORS DIDN'T WORK");    }    //go back to top (get sensor values)    }    // delay(3000);    // motorAllStop();    // delay(5000);  */}